/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ListSidebarPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/ListView.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_LIST_SIDEBAR = "list-sidebar-view";
var ListView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.lists = [];
    this.mainContainer = null;
    this.fileChangeDebounceTimer = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_LIST_SIDEBAR;
  }
  getDisplayText() {
    return "List Sidebar";
  }
  getIcon() {
    return "layers";
  }
  async onOpen() {
    await this.loadData();
    this.render();
  }
  async onClose() {
  }
  async loadData() {
    this.lists = await this.plugin.loadLists();
  }
  async saveData() {
    await this.plugin.saveLists(this.lists);
  }
  render() {
    const container = this.containerEl.children[1];
    if (!container) {
      return;
    }
    container.empty();
    container.addClass("list-sidebar-container");
    this.mainContainer = container;
    const listsContainer = container.createDiv("list-sidebar-lists");
    listsContainer.ondragover = (e) => {
      const draggingItem = container.querySelector(".list-sidebar-item.dragging");
      const draggingList = container.querySelector(".list-sidebar-list.dragging");
      if (draggingItem) {
        e.preventDefault();
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = "none";
        }
      } else if (draggingList) {
        e.preventDefault();
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = "move";
        }
      }
    };
    listsContainer.ondrop = async (e) => {
      const draggingItem = container.querySelector(".list-sidebar-item.dragging");
      const draggingList = container.querySelector(".list-sidebar-list.dragging");
      if (draggingItem) {
        e.preventDefault();
        this.render();
      } else if (draggingList) {
        e.preventDefault();
        if (e.dataTransfer) {
          const fromIndex = parseInt(e.dataTransfer.getData("text/plain"));
          if (!isNaN(fromIndex)) {
            const toIndex = Array.from(listsContainer.children).filter(
              (el) => el.classList.contains("list-sidebar-list")
            ).indexOf(draggingList);
            if (toIndex >= 0 && toIndex < this.lists.length && fromIndex !== toIndex) {
              draggingList.dataset.dragProcessed = "true";
              const [movedList] = this.lists.splice(fromIndex, 1);
              this.lists.splice(toIndex, 0, movedList);
              await this.saveData();
            }
          }
        }
      }
    };
    container.ondragover = (e) => {
      const dragging = container.querySelector(".list-sidebar-item.dragging");
      if (dragging) {
        const target = e.target;
        const itemsContainer = target.closest(".list-sidebar-items");
        if (!itemsContainer) {
          e.preventDefault();
          if (e.dataTransfer) {
            e.dataTransfer.dropEffect = "none";
          }
        } else {
          e.preventDefault();
          if (e.dataTransfer) {
            e.dataTransfer.dropEffect = "move";
          }
        }
      }
    };
    container.ondrop = (e) => {
      const dragging = container.querySelector(".list-sidebar-item.dragging");
      if (dragging) {
        const target = e.target;
        const itemsContainer = target.closest(".list-sidebar-items");
        if (!itemsContainer) {
          e.preventDefault();
          this.render();
        }
      }
    };
    this.lists.forEach((list, listIndex) => {
      this.renderList(listsContainer, list, listIndex);
    });
    const addListBtn = container.createEl("button", {
      cls: "list-sidebar-add-list-btn",
      attr: { "aria-label": "Add List" }
    });
    addListBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>';
    addListBtn.onclick = () => {
      this.showAddListInput(listsContainer);
    };
  }
  renderList(container, list, listIndex) {
    const listEl = container.createDiv("list-sidebar-list");
    listEl.draggable = true;
    listEl.dataset.listIndex = listIndex.toString();
    let dragStartIndex = listIndex;
    let isValidDrop = false;
    listEl.ondragstart = (e) => {
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", listIndex.toString());
      }
      listEl.classList.add("dragging");
      listEl.dataset.dragProcessed = "false";
      dragStartIndex = listIndex;
      isValidDrop = false;
    };
    listEl.ondragend = async (e) => {
      const wasProcessed = listEl.dataset.dragProcessed === "true";
      listEl.classList.remove("dragging");
      delete listEl.dataset.dragProcessed;
      if (wasProcessed || isValidDrop) {
        this.render();
        return;
      }
      const finalIndex = Array.from(container.children).filter(
        (el) => el.classList.contains("list-sidebar-list")
      ).indexOf(listEl);
      if (finalIndex === dragStartIndex) {
        this.render();
      } else if (finalIndex !== dragStartIndex) {
        const validIndex = Math.min(Math.max(0, finalIndex), this.lists.length - 1);
        if (validIndex >= 0 && validIndex !== dragStartIndex && validIndex < this.lists.length) {
          const [movedList] = this.lists.splice(dragStartIndex, 1);
          this.lists.splice(validIndex, 0, movedList);
          await this.saveData();
          this.render();
        } else {
          this.render();
        }
      }
    };
    listEl.ondragover = (e) => {
      e.preventDefault();
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = "move";
      }
      const afterElement = this.getDragAfterElement(container, e.clientY, "list");
      const dragging = container.querySelector(".dragging");
      if (dragging) {
        if (afterElement == null) {
          container.appendChild(dragging);
        } else {
          container.insertBefore(dragging, afterElement);
        }
      }
    };
    listEl.ondrop = async (e) => {
      e.preventDefault();
      if (e.dataTransfer) {
        const fromIndex = parseInt(e.dataTransfer.getData("text/plain"));
        const toIndex = Array.from(container.children).filter(
          (el) => el.classList.contains("list-sidebar-list")
        ).indexOf(listEl);
        if (fromIndex !== toIndex && !isNaN(fromIndex) && toIndex >= 0 && toIndex < this.lists.length) {
          isValidDrop = true;
          listEl.dataset.dragProcessed = "true";
          const [movedList] = this.lists.splice(fromIndex, 1);
          this.lists.splice(toIndex, 0, movedList);
          await this.saveData();
        }
      }
    };
    const headerEl = listEl.createDiv("list-sidebar-list-header");
    headerEl.style.cursor = "pointer";
    let clickTimer = null;
    let isDoubleClick = false;
    headerEl.onclick = async (e) => {
      if (e.target.closest(".list-sidebar-delete-btn")) {
        return;
      }
      if (e.target.closest(".list-sidebar-list-name")) {
        if (clickTimer) {
          clearTimeout(clickTimer);
          clickTimer = null;
        }
        clickTimer = setTimeout(async () => {
          if (!isDoubleClick) {
            list.expanded = !list.expanded;
            await this.saveData();
            this.render();
          }
          isDoubleClick = false;
          clickTimer = null;
        }, 300);
        return;
      }
      list.expanded = !list.expanded;
      await this.saveData();
      this.render();
    };
    const toggleBtn = headerEl.createDiv("list-sidebar-toggle-btn");
    toggleBtn.innerHTML = list.expanded ? '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"></polyline></svg>' : '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>';
    const nameEl = headerEl.createEl("span", {
      text: list.name,
      cls: "list-sidebar-list-name"
    });
    nameEl.style.cursor = "pointer";
    nameEl.ondblclick = (e) => {
      e.stopPropagation();
      isDoubleClick = true;
      if (clickTimer) {
        clearTimeout(clickTimer);
        clickTimer = null;
      }
      this.showEditListNameInput(nameEl, listIndex, list.name);
    };
    const deleteListBtn = headerEl.createEl("button", {
      cls: "list-sidebar-delete-btn",
      attr: { "aria-label": "Delete List" }
    });
    deleteListBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>';
    deleteListBtn.onclick = async () => {
      const confirmed = await this.showConfirmDialog(`Delete list "${list.name}"?`);
      if (confirmed) {
        this.lists.splice(listIndex, 1);
        await this.saveData();
        this.render();
      }
    };
    if (list.expanded) {
      const itemsContainer = listEl.createDiv("list-sidebar-items");
      if (this.plugin.settings.showDividers) {
        itemsContainer.classList.add("show-dividers");
      }
      itemsContainer.ondragover = (e) => {
        var _a;
        const listEl2 = itemsContainer.closest(".list-sidebar-list");
        if (!listEl2) {
          return;
        }
        const dragging = (_a = this.mainContainer) == null ? void 0 : _a.querySelector(".list-sidebar-item.dragging");
        if (!dragging)
          return;
        if (!dragging.classList.contains("list-sidebar-item"))
          return;
        e.preventDefault();
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = "move";
        }
        const items = Array.from(itemsContainer.children).filter(
          (el) => el.classList.contains("list-sidebar-item")
        );
        const addBtn = itemsContainer.querySelector(".list-sidebar-add-item-btn");
        if (addBtn) {
          itemsContainer.insertBefore(dragging, addBtn);
        } else {
          itemsContainer.appendChild(dragging);
        }
      };
      itemsContainer.ondrop = async (e) => {
        var _a;
        const listEl2 = itemsContainer.closest(".list-sidebar-list");
        if (!listEl2) {
          e.preventDefault();
          this.render();
          return;
        }
        const targetListIndex = parseInt(listEl2.dataset.listIndex || "-1");
        if (targetListIndex < 0 || targetListIndex >= this.lists.length) {
          e.preventDefault();
          this.render();
          return;
        }
        const dragging = (_a = this.mainContainer) == null ? void 0 : _a.querySelector(".list-sidebar-item.dragging");
        if (!dragging)
          return;
        if (!dragging.classList.contains("list-sidebar-item"))
          return;
        e.preventDefault();
        if (e.dataTransfer) {
          try {
            const data = JSON.parse(e.dataTransfer.getData("text/plain"));
            const fromListIndex = data.listIndex;
            const fromItemIndex = data.itemIndex;
            const items = Array.from(itemsContainer.children).filter(
              (el) => el.classList.contains("list-sidebar-item")
            );
            const toItemIndex = items.indexOf(dragging);
            if (!isNaN(fromListIndex) && !isNaN(fromItemIndex) && !isNaN(toItemIndex) && toItemIndex >= 0 && fromListIndex >= 0 && fromListIndex < this.lists.length && fromItemIndex >= 0 && fromItemIndex < this.lists[fromListIndex].items.length && toItemIndex <= this.lists[targetListIndex].items.length) {
              if (fromListIndex === targetListIndex && fromItemIndex !== toItemIndex) {
                dragging.dataset.dragProcessed = "true";
                const [movedItem] = this.lists[targetListIndex].items.splice(fromItemIndex, 1);
                this.lists[targetListIndex].items.splice(toItemIndex, 0, movedItem);
                await this.saveData();
              } else if (fromListIndex !== targetListIndex) {
                dragging.dataset.dragProcessed = "true";
                const [movedItem] = this.lists[fromListIndex].items.splice(fromItemIndex, 1);
                this.lists[targetListIndex].items.splice(toItemIndex, 0, movedItem);
                await this.saveData();
              }
            }
          } catch (error) {
            this.render();
          }
        }
      };
      list.items.forEach((item, itemIndex) => {
        this.renderItem(itemsContainer, item, listIndex, itemIndex, list.items.length);
      });
      const addItemBtn = itemsContainer.createEl("button", {
        cls: "list-sidebar-add-item-btn",
        attr: { "aria-label": "Add Item" }
      });
      addItemBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>';
      addItemBtn.onclick = () => {
        this.showAddItemInput(itemsContainer, listIndex);
      };
    }
  }
  renderItem(container, item, listIndex, itemIndex, totalItems) {
    const itemEl = container.createDiv("list-sidebar-item");
    itemEl.style.cursor = "pointer";
    itemEl.draggable = true;
    itemEl.dataset.itemIndex = itemIndex.toString();
    itemEl.dataset.listIndex = listIndex.toString();
    if (this.plugin.settings.alternateBackground && itemIndex % 2 === 1) {
      itemEl.classList.add("list-sidebar-item-alternate");
    }
    let dragStartItemIndex = itemIndex;
    let dragStartListIndex = listIndex;
    let isValidItemDrop = false;
    itemEl.ondragstart = (e) => {
      e.stopPropagation();
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", JSON.stringify({ listIndex, itemIndex }));
        const dragImage = document.createElement("div");
        dragImage.style.position = "absolute";
        dragImage.style.top = "-1000px";
        dragImage.style.width = "1px";
        dragImage.style.height = "1px";
        dragImage.style.opacity = "0";
        document.body.appendChild(dragImage);
        e.dataTransfer.setDragImage(dragImage, 0, 0);
        setTimeout(() => {
          document.body.removeChild(dragImage);
        }, 0);
      }
      itemEl.classList.add("dragging");
      itemEl.dataset.dragProcessed = "false";
      dragStartItemIndex = itemIndex;
      dragStartListIndex = listIndex;
      isValidItemDrop = false;
    };
    itemEl.ondragend = async (e) => {
      const wasProcessed = itemEl.dataset.dragProcessed === "true";
      itemEl.classList.remove("dragging");
      delete itemEl.dataset.dragProcessed;
      if (wasProcessed || isValidItemDrop) {
        this.render();
        return;
      }
      const itemsContainer = itemEl.closest(".list-sidebar-items");
      if (!itemsContainer) {
        this.render();
        return;
      }
      const finalListEl = itemsContainer.closest(".list-sidebar-list");
      if (!finalListEl) {
        this.render();
        return;
      }
      const finalListIndex = parseInt(finalListEl.dataset.listIndex || "-1");
      if (finalListIndex < 0 || finalListIndex >= this.lists.length) {
        this.render();
        return;
      }
      const finalIndex = Array.from(itemsContainer.children).filter(
        (el) => el.classList.contains("list-sidebar-item")
      ).indexOf(itemEl);
      if (finalListIndex === dragStartListIndex && finalIndex === dragStartItemIndex) {
        this.render();
      } else if (finalIndex >= 0 && finalIndex <= this.lists[finalListIndex].items.length) {
        if (finalListIndex === dragStartListIndex) {
          const [movedItem] = this.lists[dragStartListIndex].items.splice(dragStartItemIndex, 1);
          this.lists[dragStartListIndex].items.splice(finalIndex, 0, movedItem);
        } else {
          const [movedItem] = this.lists[dragStartListIndex].items.splice(dragStartItemIndex, 1);
          this.lists[finalListIndex].items.splice(finalIndex, 0, movedItem);
        }
        await this.saveData();
        this.render();
      } else {
        this.render();
      }
    };
    itemEl.ondragover = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = "move";
      }
      const afterElement = this.getDragAfterElement(container, e.clientY, "item");
      let dragging = container.querySelector(".list-sidebar-item.dragging");
      if (!dragging && this.mainContainer) {
        dragging = this.mainContainer.querySelector(".list-sidebar-item.dragging");
      }
      if (dragging) {
        if (afterElement == null) {
          container.appendChild(dragging);
        } else {
          container.insertBefore(dragging, afterElement);
        }
      }
    };
    itemEl.ondrop = async (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (e.dataTransfer) {
        try {
          const data = JSON.parse(e.dataTransfer.getData("text/plain"));
          const fromListIndex = data.listIndex;
          const fromItemIndex = data.itemIndex;
          const toItemIndex = Array.from(container.children).filter(
            (el) => el.classList.contains("list-sidebar-item")
          ).indexOf(itemEl);
          const targetListEl = container.closest(".list-sidebar-list");
          const targetListIndex = targetListEl ? parseInt(targetListEl.dataset.listIndex || "-1") : -1;
          if (!isNaN(fromListIndex) && !isNaN(fromItemIndex) && !isNaN(toItemIndex) && toItemIndex >= 0 && fromListIndex >= 0 && fromListIndex < this.lists.length && fromItemIndex >= 0 && fromItemIndex < this.lists[fromListIndex].items.length && targetListIndex >= 0 && targetListIndex < this.lists.length && toItemIndex <= this.lists[targetListIndex].items.length) {
            if (fromListIndex === targetListIndex && fromItemIndex !== toItemIndex) {
              isValidItemDrop = true;
              itemEl.dataset.dragProcessed = "true";
              const [movedItem] = this.lists[targetListIndex].items.splice(fromItemIndex, 1);
              this.lists[targetListIndex].items.splice(toItemIndex, 0, movedItem);
              await this.saveData();
            } else if (fromListIndex !== targetListIndex) {
              isValidItemDrop = true;
              itemEl.dataset.dragProcessed = "true";
              const [movedItem] = this.lists[fromListIndex].items.splice(fromItemIndex, 1);
              this.lists[targetListIndex].items.splice(toItemIndex, 0, movedItem);
              await this.saveData();
            }
          }
        } catch (error) {
          this.render();
        }
      }
    };
    const contentEl = itemEl.createDiv("list-sidebar-item-content");
    contentEl.createEl("span", {
      text: item.content
    });
    itemEl.ondblclick = (e) => {
      e.stopPropagation();
      this.showEditItemInput(itemEl, contentEl, listIndex, itemIndex, item.content);
    };
    const btnContainer = itemEl.createDiv("list-sidebar-item-buttons");
    const deleteItemBtn = btnContainer.createEl("button", {
      cls: "list-sidebar-delete-item-btn",
      attr: { "aria-label": "Delete Item" }
    });
    deleteItemBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>';
    deleteItemBtn.onclick = async () => {
      this.lists[listIndex].items.splice(itemIndex, 1);
      await this.saveData();
      this.render();
    };
  }
  /**
   * 处理文件变更事件，使用防抖避免高频刷新
   */
  async handleFileChanged() {
    if (this.fileChangeDebounceTimer) {
      clearTimeout(this.fileChangeDebounceTimer);
    }
    this.fileChangeDebounceTimer = setTimeout(async () => {
      const hasActiveInput = this.containerEl.querySelector(".list-sidebar-inline-input");
      if (hasActiveInput) {
        console.log("\u7528\u6237\u6B63\u5728\u8F93\u5165\uFF0C\u8DF3\u8FC7\u8FD9\u6B21\u6587\u4EF6\u5237\u65B0");
        return;
      }
      const prevListCount = this.lists.length;
      await this.loadData();
      const newListCount = this.lists.length;
      if (prevListCount > 0 && newListCount === 0) {
        console.warn("\u6587\u4EF6\u52A0\u8F7D\u540E\u6570\u636E\u4E3A\u7A7A\uFF0C\u68C0\u67E5\u6587\u4EF6\u8DEF\u5F84\u548C\u8BFB\u53D6\u903B\u8F91");
      }
      this.render();
    }, 200);
  }
  async refresh() {
    await this.loadData();
    this.render();
  }
  getDragAfterElement(container, y, type) {
    const draggableElements = Array.from(container.children).filter((el) => {
      return el.classList.contains(type === "list" ? "list-sidebar-list" : "list-sidebar-item") && !el.classList.contains("dragging");
    });
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      if (offset < 0 && offset > closest.offset) {
        return { offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
  }
  async showConfirmDialog(message) {
    return new Promise((resolve) => {
      const modal = new ConfirmModal(this.app, message, (confirmed) => {
        resolve(confirmed);
      });
      modal.open();
    });
  }
  showAddListInput(container) {
    const textareaEl = container.createEl("textarea", {
      cls: "list-sidebar-inline-input"
    });
    textareaEl.placeholder = "List name";
    textareaEl.rows = 1;
    const adjustHeight = () => {
      textareaEl.style.height = "auto";
      textareaEl.style.height = textareaEl.scrollHeight + "px";
    };
    textareaEl.addEventListener("input", adjustHeight);
    let isFinished = false;
    const finishInput = async () => {
      if (isFinished)
        return;
      isFinished = true;
      const value = textareaEl.value.trim();
      if (value) {
        const newList = {
          name: value,
          expanded: true,
          items: []
        };
        this.lists.push(newList);
        await this.saveData();
        this.render();
      } else {
        textareaEl.remove();
      }
    };
    textareaEl.focus();
    let isComposing = false;
    textareaEl.addEventListener("compositionstart", () => {
      isComposing = true;
    });
    textareaEl.addEventListener("compositionend", () => {
      isComposing = false;
    });
    textareaEl.onkeydown = async (e) => {
      if (e.key === "Enter" && !e.shiftKey && !isComposing) {
        e.preventDefault();
        await finishInput();
      } else if (e.key === "Escape") {
        e.preventDefault();
        textareaEl.remove();
      }
    };
    textareaEl.onblur = async () => {
      await finishInput();
    };
  }
  showAddItemInput(container, listIndex) {
    const textareaEl = container.createEl("textarea", {
      cls: "list-sidebar-inline-input"
    });
    textareaEl.placeholder = "Item content";
    textareaEl.rows = 1;
    const adjustHeight = () => {
      textareaEl.style.height = "auto";
      textareaEl.style.height = textareaEl.scrollHeight + "px";
    };
    textareaEl.addEventListener("input", adjustHeight);
    let isFinished = false;
    const finishInput = async () => {
      if (isFinished)
        return;
      isFinished = true;
      const value = textareaEl.value.trim();
      if (value) {
        const newItem = {
          content: value
        };
        this.lists[listIndex].items.push(newItem);
        await this.saveData();
        this.render();
      } else {
        textareaEl.remove();
      }
    };
    textareaEl.focus();
    let isComposing = false;
    textareaEl.addEventListener("compositionstart", () => {
      isComposing = true;
    });
    textareaEl.addEventListener("compositionend", () => {
      isComposing = false;
    });
    textareaEl.onkeydown = async (e) => {
      if (e.key === "Enter" && !e.shiftKey && !isComposing) {
        e.preventDefault();
        await finishInput();
      } else if (e.key === "Escape") {
        e.preventDefault();
        textareaEl.remove();
      }
    };
    textareaEl.onblur = async () => {
      await finishInput();
    };
  }
  showEditListNameInput(nameEl, listIndex, currentValue) {
    const originalText = nameEl.textContent;
    nameEl.empty();
    const textareaEl = nameEl.createEl("textarea", {
      cls: "list-sidebar-inline-input"
    });
    textareaEl.value = currentValue;
    textareaEl.rows = 1;
    const adjustHeight = () => {
      textareaEl.style.height = "auto";
      textareaEl.style.height = textareaEl.scrollHeight + "px";
    };
    adjustHeight();
    textareaEl.addEventListener("input", adjustHeight);
    let isFinished = false;
    const finishInput = async () => {
      if (isFinished)
        return;
      isFinished = true;
      const value = textareaEl.value.trim();
      if (value && value !== currentValue) {
        this.lists[listIndex].name = value;
        await this.saveData();
        this.render();
      } else if (!value) {
        this.render();
      } else {
        this.render();
      }
    };
    textareaEl.focus();
    textareaEl.select();
    let isComposing = false;
    textareaEl.addEventListener("compositionstart", () => {
      isComposing = true;
    });
    textareaEl.addEventListener("compositionend", () => {
      isComposing = false;
    });
    textareaEl.onkeydown = async (e) => {
      if (e.key === "Enter" && !e.shiftKey && !isComposing) {
        e.preventDefault();
        await finishInput();
      } else if (e.key === "Escape") {
        e.preventDefault();
        this.render();
      }
    };
    textareaEl.onblur = async () => {
      await finishInput();
    };
  }
  showEditItemInput(itemEl, contentEl, listIndex, itemIndex, currentValue) {
    contentEl.empty();
    const textareaEl = contentEl.createEl("textarea", {
      cls: "list-sidebar-inline-input"
    });
    textareaEl.value = currentValue;
    textareaEl.rows = 1;
    const adjustHeight = () => {
      textareaEl.style.height = "auto";
      textareaEl.style.height = textareaEl.scrollHeight + "px";
    };
    adjustHeight();
    textareaEl.addEventListener("input", adjustHeight);
    let isFinished = false;
    const finishInput = async () => {
      if (isFinished)
        return;
      isFinished = true;
      const value = textareaEl.value.trim();
      if (value && value !== currentValue) {
        this.lists[listIndex].items[itemIndex].content = value;
        await this.saveData();
        this.render();
      } else if (!value) {
        this.lists[listIndex].items.splice(itemIndex, 1);
        await this.saveData();
        this.render();
      } else {
        this.render();
      }
    };
    textareaEl.focus();
    textareaEl.select();
    let isComposing = false;
    textareaEl.addEventListener("compositionstart", () => {
      isComposing = true;
    });
    textareaEl.addEventListener("compositionend", () => {
      isComposing = false;
    });
    textareaEl.onkeydown = async (e) => {
      if (e.key === "Enter" && !e.shiftKey && !isComposing) {
        e.preventDefault();
        await finishInput();
      } else if (e.key === "Escape") {
        e.preventDefault();
        this.render();
      }
    };
    textareaEl.onblur = async () => {
      await finishInput();
    };
  }
};
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app, message, onSubmit) {
    super(app);
    this.message = message;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createDiv("modal-button-container");
    const confirmBtn = buttonContainer.createEl("button", {
      text: "OK",
      cls: "mod-cta"
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    confirmBtn.onclick = () => {
      this.onSubmit(true);
      this.close();
    };
    cancelBtn.onclick = () => {
      this.onSubmit(false);
      this.close();
    };
    confirmBtn.focus();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  filePath: "list-sidebar-data.md",
  showDividers: true,
  alternateBackground: true
};
var ListSidebarPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_LIST_SIDEBAR,
      (leaf) => {
        const view = new ListView(leaf, this);
        this.listView = view;
        return view;
      }
    );
    this.addRibbonIcon("layers", "List Sidebar", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-list-sidebar",
      name: "Open List Sidebar",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new ListSidebarSettingTab(this.app, this));
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian2.TFile && file.path === this.settings.filePath) {
          if (this.listView) {
            this.listView.handleFileChanged();
          }
        }
      })
    );
    this.app.workspace.onLayoutReady(() => {
      this.activateView();
    });
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_LIST_SIDEBAR);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (this.settings.filePath) {
      this.settings.filePath = this.normalizePath(this.settings.filePath);
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_LIST_SIDEBAR)[0];
    if (!leaf) {
      const newLeaf = workspace.getLeftLeaf(false);
      if (newLeaf) {
        await newLeaf.setViewState({ type: VIEW_TYPE_LIST_SIDEBAR, active: true });
        leaf = newLeaf;
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async loadLists() {
    try {
      const normalizedPath = this.normalizePath(this.settings.filePath);
      let file = this.app.vault.getAbstractFileByPath(normalizedPath);
      if (!file || !(file instanceof import_obsidian2.TFile)) {
        file = this.app.vault.getAbstractFileByPath(this.settings.filePath);
        if (file && file instanceof import_obsidian2.TFile) {
          this.settings.filePath = file.path;
          await this.saveSettings();
          console.log("loadLists: \u4F7F\u7528\u539F\u59CB\u8DEF\u5F84\u627E\u5230\u6587\u4EF6", this.settings.filePath);
        }
      }
      if (!file && this.settings.filePath.includes("\\")) {
        const unixStylePath = this.settings.filePath.replace(/\\/g, "/");
        console.log("loadLists: \u5C1D\u8BD5Unix\u98CE\u683C\u8DEF\u5F84", unixStylePath);
        file = this.app.vault.getAbstractFileByPath(unixStylePath);
        if (file && file instanceof import_obsidian2.TFile) {
          this.settings.filePath = file.path;
          await this.saveSettings();
        }
      }
      if (!file) {
        console.warn("loadLists: \u65E0\u6CD5\u5728\u6307\u5B9A\u8DEF\u5F84\u627E\u5230\u6587\u4EF6", normalizedPath);
        console.warn("loadLists: \u68C0\u67E5vault\u4E2D\u662F\u5426\u6709list-sidebar-data.md\u6587\u4EF6");
        const allFiles = this.app.vault.getFiles();
        const dataFiles = allFiles.filter(
          (f) => f.path.includes("list-sidebar-data") || f.path.endsWith(".md")
        );
        if (dataFiles.length > 0 && !normalizedPath.includes("/")) {
          const rootFile = dataFiles.find((f) => !f.path.includes("/"));
          if (rootFile) {
            file = rootFile;
            this.settings.filePath = rootFile.path;
            await this.saveSettings();
            new import_obsidian2.Notice(`\u4ECE "${file.path}" \u52A0\u8F7D\u6570\u636E`);
          }
        }
      }
      if (!file || !(file instanceof import_obsidian2.TFile)) {
        console.log("loadLists: \u6587\u4EF6\u4E0D\u5B58\u5728\uFF0C\u8FD4\u56DE\u7A7A\u5217\u8868");
        return [];
      }
      console.log("loadLists: \u6210\u529F\u627E\u5230\u6587\u4EF6", file.path);
      const content = await this.app.vault.read(file);
      const parsedLists = this.parseMarkdownFile(content);
      console.log("loadLists: \u89E3\u6790\u7ED3\u679C - \u5217\u8868\u6570\u91CF:", parsedLists.length);
      return parsedLists;
    } catch (error) {
      console.error("\u52A0\u8F7D\u5217\u8868\u6570\u636E\u5931\u8D25:", error);
      console.error("\u5C1D\u8BD5\u7684\u8DEF\u5F84:", this.settings.filePath);
      return [];
    }
  }
  async saveLists(lists) {
    try {
      if (lists.length === 0 && this.settings.filePath === "list-sidebar-data.md") {
        let normalizedPath2 = this.normalizePath(this.settings.filePath);
        let existingFile = this.app.vault.getAbstractFileByPath(normalizedPath2);
        if (!existingFile && this.settings.filePath.includes("\\")) {
          const unixStylePath = this.settings.filePath.replace(/\\/g, "/");
          existingFile = this.app.vault.getAbstractFileByPath(unixStylePath);
        }
        if (existingFile && existingFile instanceof import_obsidian2.TFile) {
          const existingContent = await this.app.vault.read(existingFile);
          const existingLists = this.parseMarkdownFile(existingContent);
          if (existingLists.length > 0 && lists.length === 0) {
            console.error("\u4FDD\u5B58\u88AB\u62D2\u7EDD\uFF1A\u8BD5\u56FE\u7528\u7A7A\u6570\u636E\u8986\u76D6\u5DF2\u5B58\u5728\u6570\u636E\u7684\u6587\u4EF6");
            console.error("\u73B0\u6709\u5217\u8868\u6570\u91CF:", existingLists.length);
            new import_obsidian2.Notice("\u4FDD\u5B58\u5931\u8D25\uFF1A\u6587\u4EF6\u5305\u542B\u6570\u636E\uFF0C\u4E0D\u80FD\u8986\u76D6\u4E3A\u7A7A");
            return;
          }
        }
      }
      if (lists.length === 0) {
        let normalizedPath2 = this.normalizePath(this.settings.filePath);
        let existingFile = this.app.vault.getAbstractFileByPath(normalizedPath2);
        if (!existingFile && this.settings.filePath.includes("\\")) {
          const unixStylePath = this.settings.filePath.replace(/\\/g, "/");
          existingFile = this.app.vault.getAbstractFileByPath(unixStylePath);
        }
        if (existingFile && existingFile instanceof import_obsidian2.TFile) {
          const existingContent = await this.app.vault.read(existingFile);
          const existingLists = this.parseMarkdownFile(existingContent);
          if (existingLists.length > 3) {
            console.error("\u4FDD\u5B58\u88AB\u62D2\u7EDD\uFF1A\u6587\u4EF6\u6709\u591A\u4E2A\u5217\u8868\u4F46\u8BD5\u56FE\u4FDD\u5B58\u4E3A\u7A7A");
            new import_obsidian2.Notice("\u4FDD\u5B58\u5931\u8D25\uFF1A\u68C0\u6D4B\u5230\u6570\u636E\u4E22\u5931\u98CE\u9669");
            return;
          }
        }
      }
      const content = this.generateMarkdownFile(lists);
      if (content.length < 30 && lists.length > 2) {
        console.error("\u4FDD\u5B58\u88AB\u62D2\u7EDD\uFF1A\u751F\u6210\u7684\u5185\u5BB9\u5F02\u5E38\u77ED\u4F46\u5217\u8868\u6570\u91CF\u8F83\u591A");
        console.error("\u5217\u8868\u6570\u91CF:", lists.length, "\u5185\u5BB9\u957F\u5EA6:", content.length);
        new import_obsidian2.Notice("\u4FDD\u5B58\u5931\u8D25\uFF1A\u5185\u5BB9\u751F\u6210\u5F02\u5E38");
        return;
      }
      let normalizedPath = this.normalizePath(this.settings.filePath);
      let file = this.app.vault.getAbstractFileByPath(normalizedPath);
      if (!file || !(file instanceof import_obsidian2.TFile)) {
        file = this.app.vault.getAbstractFileByPath(this.settings.filePath);
        if (file && file instanceof import_obsidian2.TFile) {
          this.settings.filePath = file.path;
          await this.saveSettings();
          console.log("saveLists: \u4F7F\u7528\u539F\u59CB\u8DEF\u5F84\u627E\u5230\u6587\u4EF6", this.settings.filePath);
        }
      }
      if (!file && this.settings.filePath.includes("\\")) {
        const unixStylePath = this.settings.filePath.replace(/\\/g, "/");
        console.log("saveLists: \u5C1D\u8BD5Unix\u98CE\u683C\u8DEF\u5F84", unixStylePath);
        file = this.app.vault.getAbstractFileByPath(unixStylePath);
        if (file && file instanceof import_obsidian2.TFile) {
          this.settings.filePath = file.path;
          await this.saveSettings();
        }
      }
      if (file && file instanceof import_obsidian2.TFile) {
        await this.app.vault.modify(file, content);
        console.log("saveLists: \u6210\u529F\u66F4\u65B0\u6587\u4EF6", file.path, "\u5217\u8868\u6570\u91CF:", lists.length);
      } else {
        await this.app.vault.create(normalizedPath, content);
        console.log("saveLists: \u6210\u529F\u521B\u5EFA\u65B0\u6587\u4EF6", normalizedPath);
      }
    } catch (error) {
      console.error("\u4FDD\u5B58\u5217\u8868\u6570\u636E\u5931\u8D25:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      new import_obsidian2.Notice("\u4FDD\u5B58\u5217\u8868\u6570\u636E\u5931\u8D25: " + errorMessage);
    }
  }
  parseMarkdownFile(content) {
    const lists = [];
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n/);
    let metadata = {};
    if (frontmatterMatch) {
      try {
        const yamlContent = frontmatterMatch[1];
        const lines = yamlContent.split("\n");
        let currentList = null;
        lines.forEach((line) => {
          const listMatch = line.match(/^(\w+):$/);
          if (listMatch) {
            if (currentList) {
              lists.push(currentList);
            }
            currentList = {
              name: listMatch[1],
              expanded: true,
              items: []
            };
          } else if (currentList && line.trim().startsWith("- ")) {
            const itemContent = line.trim().substring(2);
            currentList.items.push({ content: itemContent });
          } else if (line.trim().startsWith("expanded:")) {
            currentList.expanded = line.trim().substring(9).trim() === "true";
          }
        });
        if (currentList) {
          lists.push(currentList);
        }
      } catch (e) {
        console.error("\u89E3\u6790YAML\u5931\u8D25:", e);
      }
    }
    if (lists.length === 0) {
      const bodyContent = frontmatterMatch ? content.substring(frontmatterMatch[0].length) : content;
      const lines = bodyContent.split("\n");
      let currentList = null;
      lines.forEach((line) => {
        const listHeaderMatch = line.match(/^## (.+?)(\s*<!--.*?-->)?$/);
        if (listHeaderMatch) {
          if (currentList) {
            lists.push(currentList);
          }
          const listName = listHeaderMatch[1].trim();
          const expandedComment = listHeaderMatch[2] || "";
          const isExpanded = expandedComment.includes("expanded:true");
          currentList = {
            name: listName,
            expanded: isExpanded,
            items: []
          };
        } else if (currentList && line.trim().startsWith("- ")) {
          const itemContent = line.trim().substring(2);
          currentList.items.push({ content: itemContent });
        }
      });
      if (currentList) {
        lists.push(currentList);
      }
    }
    return lists.length > 0 ? lists : [];
  }
  generateMarkdownFile(lists) {
    let content = "";
    lists.forEach((list, index) => {
      if (index > 0) {
        content += "\n";
      }
      const expandedMarker = list.expanded ? "<!-- expanded:true -->" : "<!-- expanded:false -->";
      content += `## ${list.name} ${expandedMarker}

`;
      list.items.forEach((item) => {
        content += `- ${item.content}
`;
      });
    });
    return content;
  }
  openSettings() {
    this.app.setting.open();
    this.app.setting.openTabById(this.manifest.id);
  }
  // 路径规范化方法（改为public以便在其他地方使用）
  normalizePath(path) {
    if (!path)
      return path;
    const originalPath = path;
    path = path.replace(/\\/g, "/");
    if (this.isWindowsAbsolutePath(originalPath)) {
      const relativePath = this.convertWindowsPathToRelative(originalPath);
      console.log("convertWindowsPathToRelative:", originalPath, "->", relativePath);
      return relativePath;
    }
    path = path.replace(/^\/+|\/+$/g, "");
    path = path.replace(/\/+/g, "/");
    return path;
  }
  isWindowsAbsolutePath(path) {
    return /^[a-zA-Z]:[/\\]/.test(path);
  }
  convertWindowsPathToRelative(windowsPath) {
    let path = windowsPath.replace(/\\/g, "/");
    path = path.replace(/^[a-zA-Z]:[/\\]?/, "");
    const vaultPath = this.app.vault.adapter.basePath || "";
    if (vaultPath && path.includes(vaultPath)) {
      const index = path.indexOf(vaultPath);
      if (index >= 0) {
        path = path.substring(index + vaultPath.length);
        path = path.replace(/^[/\\]+/, "");
      }
    }
    return path;
  }
};
var ListSidebarSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "List Sidebar Settings" });
    new import_obsidian2.Setting(containerEl).setName("Data File Path").setDesc("Markdown file path to save list data (relative to vault root)").addText((text) => text.setPlaceholder("e.g., list-sidebar-data.md").setValue(this.plugin.settings.filePath).onChange(async (value) => {
      this.plugin.settings.filePath = this.plugin.normalizePath(value);
      await this.plugin.saveSettings();
      const listView = this.plugin.listView;
      if (listView) {
        await listView.refresh();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Show Dividers").setDesc("Show thin horizontal lines between items").addToggle((toggle) => toggle.setValue(this.plugin.settings.showDividers).onChange(async (value) => {
      this.plugin.settings.showDividers = value;
      await this.plugin.saveSettings();
      const listView = this.plugin.listView;
      if (listView) {
        await listView.refresh();
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Alternate Background").setDesc("Use subtle alternating background colors for items").addToggle((toggle) => toggle.setValue(this.plugin.settings.alternateBackground).onChange(async (value) => {
      this.plugin.settings.alternateBackground = value;
      await this.plugin.saveSettings();
      const listView = this.plugin.listView;
      if (listView) {
        await listView.refresh();
      }
    }));
  }
};
